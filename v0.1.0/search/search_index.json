{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"django-slack-tools","text":"<p>Little helpers working with Slack bot \ud83e\udd16 in Django.</p> <p>This project aims to implementing helpful features making Slack bot and providing reusable Django apps integrated with database.</p>"},{"location":"#features","title":"Features","text":"<p>Key features are:</p> <ul> <li> <p> Reusable Django app for Slack messaging with various messaging backends for different environments</p> </li> <li> <p> Database-backed Slack messaging policies with simple dictionary-based template</p> </li> <li> <p> Message histories</p> </li> <li> <p> Built-in admin for management working with Slack workspace</p> </li> </ul> <p>And more in future roadmap...</p> <ul> <li> <p> Celery support for messaging backends, management and shortcut tasks, etc.</p> </li> <li> <p> Django template support</p> </li> <li> <p> New Django apps and helpers for Slack features such as modals, event subscription, etc.</p> </li> </ul> <p>Currently it is focused on messaging features. In future, hoping to bring more helpful features across Slack Bot ecosystem, such as event subscriptions, modals, bot interactions, etc.</p>"},{"location":"api-references/slack-messages/messaging-backends/","title":"Messaging Backends","text":""},{"location":"api-references/slack-messages/messaging-backends/#django_slack_tools.slack_messages.backends.dummy.DummyBackend","title":"<code>django_slack_tools.slack_messages.backends.dummy.DummyBackend</code>","text":"<p>               Bases: <code>BackendBase</code></p> <p>An dummy backend that does nothing with message.</p> Source code in <code>django_slack_tools/slack_messages/backends/dummy.py</code> <pre><code>class DummyBackend(BackendBase):\n    \"\"\"An dummy backend that does nothing with message.\"\"\"\n\n    def send_message(self, *args: Any, **kwargs: Any) -&gt; SlackMessage:  # noqa: ARG002\n        \"\"\"This backend will not do anything, just like dummy.\"\"\"\n        return SlackMessage()\n\n    def _prepare_message(self, *args: Any, **kwargs: Any) -&gt; SlackMessage:  # noqa: ARG002\n        return SlackMessage()\n\n    def _send_message(self, *args: Any, **kwargs: Any) -&gt; SlackResponse:  # noqa: ARG002\n        return SlackResponse(\n            client=None,\n            http_verb=\"POST\",\n            api_url=\"https://www.slack.com/api/chat.postMessage\",\n            req_args={},\n            data={\"ok\": False},\n            headers={},\n            status_code=200,\n        )\n\n    def _record_request(self, *args: Any, **kwargs: Any) -&gt; Any: ...\n\n    def _record_response(self, *args: Any, **kwargs: Any) -&gt; Any: ...\n</code></pre>"},{"location":"api-references/slack-messages/messaging-backends/#django_slack_tools.slack_messages.backends.dummy.DummyBackend.send_message","title":"<code>send_message(*args, **kwargs)</code>","text":"<p>This backend will not do anything, just like dummy.</p> Source code in <code>django_slack_tools/slack_messages/backends/dummy.py</code> <pre><code>def send_message(self, *args: Any, **kwargs: Any) -&gt; SlackMessage:  # noqa: ARG002\n    \"\"\"This backend will not do anything, just like dummy.\"\"\"\n    return SlackMessage()\n</code></pre>"},{"location":"api-references/slack-messages/messaging-backends/#django_slack_tools.slack_messages.backends.logging.LoggingBackend","title":"<code>django_slack_tools.slack_messages.backends.logging.LoggingBackend</code>","text":"<p>               Bases: <code>DummyBackend</code></p> <p>Backend that log the message rather than sending it.</p> Source code in <code>django_slack_tools/slack_messages/backends/logging.py</code> <pre><code>class LoggingBackend(DummyBackend):\n    \"\"\"Backend that log the message rather than sending it.\"\"\"\n\n    def _send_message(self, *args: Any, **kwargs: Any) -&gt; SlackResponse:\n        logger.debug(\"Sending an message with following args=%r, kwargs=%r\", args, kwargs)\n        return super()._send_message(*args, **kwargs)\n\n    def _record_request(self, *args: Any, **kwargs: Any) -&gt; Any:\n        logger.debug(\"Recording request with args=%r, kwargs=%r\", args, kwargs)\n\n    def _record_response(self, *args: Any, **kwargs: Any) -&gt; Any:\n        logger.debug(\"Recording response with args=%r, kwargs=%r\", args, kwargs)\n</code></pre>"},{"location":"api-references/slack-messages/messaging-backends/#django_slack_tools.slack_messages.backends.slack.SlackBackend","title":"<code>django_slack_tools.slack_messages.backends.slack.SlackBackend</code>","text":"<p>               Bases: <code>BackendBase</code></p> <p>Backend actually sending the messages.</p> Source code in <code>django_slack_tools/slack_messages/backends/slack.py</code> <pre><code>class SlackBackend(BackendBase):\n    \"\"\"Backend actually sending the messages.\"\"\"\n\n    def __init__(\n        self,\n        *,\n        slack_app: App | Callable[[], App] | str,\n    ) -&gt; None:\n        \"\"\"Initialize backend.\n\n        Args:\n            slack_app: Slack app instance or import string.\n        \"\"\"\n        if isinstance(slack_app, str):\n            slack_app = import_string(slack_app)\n\n        if callable(slack_app):\n            slack_app = slack_app()\n\n        if not isinstance(slack_app, App):\n            msg = \"Couldn't resolve provided app spec into Slack app instance.\"\n            raise ImproperlyConfigured(msg)\n\n        self._slack_app = slack_app\n\n    def send_message(  # noqa: PLR0913\n        self,\n        message: SlackMessage | None = None,\n        *,\n        policy: SlackMessagingPolicy | None = None,\n        channel: str | None = None,\n        header: MessageHeader | None = None,\n        body: MessageBody | None = None,\n        raise_exception: bool,\n        get_permalink: bool = False,\n    ) -&gt; SlackMessage:\n        \"\"\"Send Slack message.\n\n        Args:\n            message: Externally prepared message.\n                If not given, make one using `channel`, `header` and `body` parameters.\n            policy: Messaging policy to create message with.\n            channel: Channel to send message.\n            header: Message header that controls how message will sent.\n            body: Message body describing content of the message.\n            raise_exception: Whether to re-raise caught exception while sending messages.\n            get_permalink: Try to get the message permalink via extraneous Slack API calls.\n\n        Returns:\n            Sent Slack message.\n        \"\"\"\n        if not message:\n            if not (channel and header and body):\n                msg = (\n                    \"Call signature mismatch for overload.\"\n                    \" If `message` not provided, `channel`, `header` and `body` all must given.\"\n                )\n                raise TypeError(msg)\n\n            message = self._prepare_message(policy=policy, channel=channel, header=header, body=body)\n\n        try:\n            # Send Slack message\n            response: SlackResponse\n            try:\n                response = self._send_message(message=message)\n            except SlackApiError as err:\n                if raise_exception:\n                    raise\n\n                logger.exception(\n                    \"Error occurred while sending Slack message, but ignored because `raise_exception` not set.\",\n                )\n                response = err.response\n\n            # Update message detail\n            ok: bool | None = response.get(\"ok\")\n            message.ok = ok\n            if ok:\n                # `str` if OK, otherwise `None`\n                message.ts = cast(str, response.get(\"ts\"))\n                message.parent_ts = response.get(\"message\", {}).get(\"thread_ts\", \"\")  # type: ignore[call-overload]\n                if get_permalink:\n                    message.permalink = self._get_permalink(\n                        channel=message.channel,\n                        message_ts=message.ts,\n                        raise_exception=raise_exception,\n                    )\n\n            message.request = self._record_request(response)\n            message.response = self._record_response(response)\n        except:\n            message.exception = traceback.format_exc()\n\n            # Don't omit raise with flag `raise_exception` here\n            raise\n        finally:\n            message.save()\n\n        return message\n\n    def _get_permalink(self, *, channel: str, message_ts: str, raise_exception: bool = False) -&gt; str:\n        \"\"\"Get a permalink for given message identifier.\"\"\"\n        try:\n            _permalink_resp = self._slack_app.client.chat_getPermalink(\n                channel=channel,\n                message_ts=message_ts,\n            )\n        except SlackApiError:\n            if raise_exception:\n                raise\n\n            logger.exception(\n                \"Error occurred while sending retrieving message's permalink,\"\n                \" but ignored as `raise_exception` not set.\",\n            )\n            return \"\"\n\n        return _permalink_resp.get(\"permalink\", default=\"\")\n\n    def _send_message(self, *, message: SlackMessage) -&gt; SlackResponse:\n        header = message.header or {}\n        body = message.body or {}\n        return self._slack_app.client.chat_postMessage(channel=message.channel, **header, **body)\n\n    def _record_request(self, response: SlackResponse) -&gt; dict[str, Any]:\n        # Remove auth header (token) from request before recording\n        response.req_args.get(\"headers\", {}).pop(\"Authorization\", None)\n\n        return response.req_args\n\n    def _record_response(self, response: SlackResponse) -&gt; dict[str, Any]:\n        return {\n            \"http_verb\": response.http_verb,\n            \"api_url\": response.api_url,\n            \"status_code\": response.status_code,\n            \"headers\": response.headers,\n            \"data\": response.data,\n        }\n</code></pre>"},{"location":"api-references/slack-messages/messaging-backends/#django_slack_tools.slack_messages.backends.slack.SlackBackend.__init__","title":"<code>__init__(*, slack_app)</code>","text":"<p>Initialize backend.</p> <p>Parameters:</p> Name Type Description Default <code>slack_app</code> <code>App | Callable[[], App] | str</code> <p>Slack app instance or import string.</p> required Source code in <code>django_slack_tools/slack_messages/backends/slack.py</code> <pre><code>def __init__(\n    self,\n    *,\n    slack_app: App | Callable[[], App] | str,\n) -&gt; None:\n    \"\"\"Initialize backend.\n\n    Args:\n        slack_app: Slack app instance or import string.\n    \"\"\"\n    if isinstance(slack_app, str):\n        slack_app = import_string(slack_app)\n\n    if callable(slack_app):\n        slack_app = slack_app()\n\n    if not isinstance(slack_app, App):\n        msg = \"Couldn't resolve provided app spec into Slack app instance.\"\n        raise ImproperlyConfigured(msg)\n\n    self._slack_app = slack_app\n</code></pre>"},{"location":"api-references/slack-messages/messaging-backends/#django_slack_tools.slack_messages.backends.slack.SlackBackend._get_permalink","title":"<code>_get_permalink(*, channel, message_ts, raise_exception=False)</code>","text":"<p>Get a permalink for given message identifier.</p> Source code in <code>django_slack_tools/slack_messages/backends/slack.py</code> <pre><code>def _get_permalink(self, *, channel: str, message_ts: str, raise_exception: bool = False) -&gt; str:\n    \"\"\"Get a permalink for given message identifier.\"\"\"\n    try:\n        _permalink_resp = self._slack_app.client.chat_getPermalink(\n            channel=channel,\n            message_ts=message_ts,\n        )\n    except SlackApiError:\n        if raise_exception:\n            raise\n\n        logger.exception(\n            \"Error occurred while sending retrieving message's permalink,\"\n            \" but ignored as `raise_exception` not set.\",\n        )\n        return \"\"\n\n    return _permalink_resp.get(\"permalink\", default=\"\")\n</code></pre>"},{"location":"api-references/slack-messages/messaging-backends/#django_slack_tools.slack_messages.backends.slack.SlackBackend.send_message","title":"<code>send_message(message=None, *, policy=None, channel=None, header=None, body=None, raise_exception, get_permalink=False)</code>","text":"<p>Send Slack message.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>SlackMessage | None</code> <p>Externally prepared message. If not given, make one using <code>channel</code>, <code>header</code> and <code>body</code> parameters.</p> <code>None</code> <code>policy</code> <code>SlackMessagingPolicy | None</code> <p>Messaging policy to create message with.</p> <code>None</code> <code>channel</code> <code>str | None</code> <p>Channel to send message.</p> <code>None</code> <code>header</code> <code>MessageHeader | None</code> <p>Message header that controls how message will sent.</p> <code>None</code> <code>body</code> <code>MessageBody | None</code> <p>Message body describing content of the message.</p> <code>None</code> <code>raise_exception</code> <code>bool</code> <p>Whether to re-raise caught exception while sending messages.</p> required <code>get_permalink</code> <code>bool</code> <p>Try to get the message permalink via extraneous Slack API calls.</p> <code>False</code> <p>Returns:</p> Type Description <code>SlackMessage</code> <p>Sent Slack message.</p> Source code in <code>django_slack_tools/slack_messages/backends/slack.py</code> <pre><code>def send_message(  # noqa: PLR0913\n    self,\n    message: SlackMessage | None = None,\n    *,\n    policy: SlackMessagingPolicy | None = None,\n    channel: str | None = None,\n    header: MessageHeader | None = None,\n    body: MessageBody | None = None,\n    raise_exception: bool,\n    get_permalink: bool = False,\n) -&gt; SlackMessage:\n    \"\"\"Send Slack message.\n\n    Args:\n        message: Externally prepared message.\n            If not given, make one using `channel`, `header` and `body` parameters.\n        policy: Messaging policy to create message with.\n        channel: Channel to send message.\n        header: Message header that controls how message will sent.\n        body: Message body describing content of the message.\n        raise_exception: Whether to re-raise caught exception while sending messages.\n        get_permalink: Try to get the message permalink via extraneous Slack API calls.\n\n    Returns:\n        Sent Slack message.\n    \"\"\"\n    if not message:\n        if not (channel and header and body):\n            msg = (\n                \"Call signature mismatch for overload.\"\n                \" If `message` not provided, `channel`, `header` and `body` all must given.\"\n            )\n            raise TypeError(msg)\n\n        message = self._prepare_message(policy=policy, channel=channel, header=header, body=body)\n\n    try:\n        # Send Slack message\n        response: SlackResponse\n        try:\n            response = self._send_message(message=message)\n        except SlackApiError as err:\n            if raise_exception:\n                raise\n\n            logger.exception(\n                \"Error occurred while sending Slack message, but ignored because `raise_exception` not set.\",\n            )\n            response = err.response\n\n        # Update message detail\n        ok: bool | None = response.get(\"ok\")\n        message.ok = ok\n        if ok:\n            # `str` if OK, otherwise `None`\n            message.ts = cast(str, response.get(\"ts\"))\n            message.parent_ts = response.get(\"message\", {}).get(\"thread_ts\", \"\")  # type: ignore[call-overload]\n            if get_permalink:\n                message.permalink = self._get_permalink(\n                    channel=message.channel,\n                    message_ts=message.ts,\n                    raise_exception=raise_exception,\n                )\n\n        message.request = self._record_request(response)\n        message.response = self._record_response(response)\n    except:\n        message.exception = traceback.format_exc()\n\n        # Don't omit raise with flag `raise_exception` here\n        raise\n    finally:\n        message.save()\n\n    return message\n</code></pre>"},{"location":"api-references/slack-messages/messaging-backends/#django_slack_tools.slack_messages.backends.slack.SlackRedirectBackend","title":"<code>django_slack_tools.slack_messages.backends.slack.SlackRedirectBackend</code>","text":"<p>               Bases: <code>SlackBackend</code></p> <p>Inherited Slack backend with redirection to specific channels.</p> Source code in <code>django_slack_tools/slack_messages/backends/slack.py</code> <pre><code>class SlackRedirectBackend(SlackBackend):\n    \"\"\"Inherited Slack backend with redirection to specific channels.\"\"\"\n\n    def __init__(self, *, slack_app: App | str, redirect_channel: str, inform_redirect: bool = True) -&gt; None:\n        \"\"\"Initialize backend.\n\n        Args:\n            slack_app: Slack app instance or import string.\n            redirect_channel: Slack channel to redirect.\n            inform_redirect: Whether to append an attachment informing that the message has been redirected.\n                Defaults to `True`.\n        \"\"\"\n        self.redirect_channel = redirect_channel\n        self.inform_redirect = inform_redirect\n\n        super().__init__(slack_app=slack_app)\n\n    def _prepare_message(self, *args: Any, channel: str, body: MessageBody, **kwargs: Any) -&gt; SlackMessage:\n        # Modify channel to force messages always sent to specific channel\n        # Add an attachment that informing message has been redirected\n        if self.inform_redirect:\n            body.attachments = [\n                self._make_inform_attachment(original_channel=channel),\n                *(body.attachments or []),\n            ]\n\n        return super()._prepare_message(*args, channel=self.redirect_channel, body=body, **kwargs)\n\n    def _make_inform_attachment(self, *, original_channel: str) -&gt; dict[str, Any]:\n        msg_redirect_inform = _(\n            \":warning:  This message was originally sent to channel *{channel}* but redirected here.\",\n        )\n\n        return {\n            \"color\": \"#eb4034\",\n            \"text\": msg_redirect_inform.format(channel=original_channel),\n        }\n</code></pre>"},{"location":"api-references/slack-messages/messaging-backends/#django_slack_tools.slack_messages.backends.slack.SlackRedirectBackend.__init__","title":"<code>__init__(*, slack_app, redirect_channel, inform_redirect=True)</code>","text":"<p>Initialize backend.</p> <p>Parameters:</p> Name Type Description Default <code>slack_app</code> <code>App | str</code> <p>Slack app instance or import string.</p> required <code>redirect_channel</code> <code>str</code> <p>Slack channel to redirect.</p> required <code>inform_redirect</code> <code>bool</code> <p>Whether to append an attachment informing that the message has been redirected. Defaults to <code>True</code>.</p> <code>True</code> Source code in <code>django_slack_tools/slack_messages/backends/slack.py</code> <pre><code>def __init__(self, *, slack_app: App | str, redirect_channel: str, inform_redirect: bool = True) -&gt; None:\n    \"\"\"Initialize backend.\n\n    Args:\n        slack_app: Slack app instance or import string.\n        redirect_channel: Slack channel to redirect.\n        inform_redirect: Whether to append an attachment informing that the message has been redirected.\n            Defaults to `True`.\n    \"\"\"\n    self.redirect_channel = redirect_channel\n    self.inform_redirect = inform_redirect\n\n    super().__init__(slack_app=slack_app)\n</code></pre>"},{"location":"api-references/slack-messages/models/","title":"Models","text":""},{"location":"api-references/slack-messages/models/#django_slack_tools.slack_messages.models.SlackMention","title":"<code>django_slack_tools.slack_messages.models.SlackMention</code>","text":"<p>               Bases: <code>TimestampMixin</code>, <code>Model</code></p> <p>People or group in channels receive messages.</p> Source code in <code>django_slack_tools/slack_messages/models/mention.py</code> <pre><code>class SlackMention(TimestampMixin, models.Model):\n    \"\"\"People or group in channels receive messages.\"\"\"\n\n    class MentionType(models.TextChoices):\n        \"\"\"Possible mention types.\"\"\"\n\n        USER = \"U\", _(\"User\")\n        \"User mentions. e.g. `@lasuillard`.\"\n\n        GROUP = \"G\", _(\"Group\")\n        \"Team mentions. e.g. `@backend`.\"\n\n        SPECIAL = \"S\", _(\"Special\")\n        \"Special mentions. e.g. `@here`, `@channel`, `@everyone`.\"\n\n        UNKNOWN = \"?\", _(\"Unknown\")\n        \"Unknown mention type.\"\n\n    type = models.CharField(\n        verbose_name=_(\"Type\"),\n        help_text=_(\"Type of mentions.\"),\n        max_length=1,\n        choices=MentionType.choices,\n        blank=False,\n    )\n    name = models.CharField(\n        verbose_name=_(\"Name\"),\n        help_text=_(\"Human-friendly mention name.\"),\n        max_length=128,\n    )\n    mention_id = models.CharField(\n        verbose_name=_(\"Mention ID\"),\n        help_text=_(\"User or group ID, or raw mention itself.\"),\n        max_length=32,\n    )\n\n    objects: SlackMentionManager = SlackMentionManager()\n\n    class Meta:  # noqa: D106\n        verbose_name = _(\"Mention\")\n        verbose_name_plural = _(\"Mentions\")\n\n    def __str__(self) -&gt; str:\n        return _(\"{name} ({type}, {mention_id})\").format(\n            name=self.name,\n            type=self.get_type_display(),\n            mention_id=self.mention_id,\n        )\n\n    @property\n    def mention(self) -&gt; str:\n        \"\"\"Mention string for use in messages, e.g. `\"&lt;@{USER_ID}&gt;\"`.\"\"\"\n        if self.type == SlackMention.MentionType.USER:\n            return f\"&lt;@{self.mention_id}&gt;\"\n\n        if self.type == SlackMention.MentionType.GROUP:\n            return f\"&lt;!subteam^{self.mention_id}&gt;\"\n\n        return self.mention_id\n</code></pre>"},{"location":"api-references/slack-messages/models/#django_slack_tools.slack_messages.models.SlackMention.mention","title":"<code>mention</code>  <code>property</code>","text":"<p>Mention string for use in messages, e.g. <code>\"&lt;@{USER_ID}&gt;\"</code>.</p>"},{"location":"api-references/slack-messages/models/#django_slack_tools.slack_messages.models.SlackMention.MentionType","title":"<code>MentionType</code>","text":"<p>               Bases: <code>TextChoices</code></p> <p>Possible mention types.</p> Source code in <code>django_slack_tools/slack_messages/models/mention.py</code> <pre><code>class MentionType(models.TextChoices):\n    \"\"\"Possible mention types.\"\"\"\n\n    USER = \"U\", _(\"User\")\n    \"User mentions. e.g. `@lasuillard`.\"\n\n    GROUP = \"G\", _(\"Group\")\n    \"Team mentions. e.g. `@backend`.\"\n\n    SPECIAL = \"S\", _(\"Special\")\n    \"Special mentions. e.g. `@here`, `@channel`, `@everyone`.\"\n\n    UNKNOWN = \"?\", _(\"Unknown\")\n    \"Unknown mention type.\"\n</code></pre>"},{"location":"api-references/slack-messages/models/#django_slack_tools.slack_messages.models.SlackMention.MentionType.GROUP","title":"<code>GROUP = ('G', _('Group'))</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Team mentions. e.g. <code>@backend</code>.</p>"},{"location":"api-references/slack-messages/models/#django_slack_tools.slack_messages.models.SlackMention.MentionType.SPECIAL","title":"<code>SPECIAL = ('S', _('Special'))</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Special mentions. e.g. <code>@here</code>, <code>@channel</code>, <code>@everyone</code>.</p>"},{"location":"api-references/slack-messages/models/#django_slack_tools.slack_messages.models.SlackMention.MentionType.UNKNOWN","title":"<code>UNKNOWN = ('?', _('Unknown'))</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Unknown mention type.</p>"},{"location":"api-references/slack-messages/models/#django_slack_tools.slack_messages.models.SlackMention.MentionType.USER","title":"<code>USER = ('U', _('User'))</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>User mentions. e.g. <code>@lasuillard</code>.</p>"},{"location":"api-references/slack-messages/models/#django_slack_tools.slack_messages.models.SlackMessage","title":"<code>django_slack_tools.slack_messages.models.SlackMessage</code>","text":"<p>               Bases: <code>TimestampMixin</code>, <code>Model</code></p> <p>An Slack message.</p> Source code in <code>django_slack_tools/slack_messages/models/message.py</code> <pre><code>class SlackMessage(TimestampMixin, models.Model):\n    \"\"\"An Slack message.\"\"\"\n\n    policy = models.ForeignKey(\n        SlackMessagingPolicy,\n        verbose_name=_(\"Messaging Policy\"),\n        help_text=_(\"Messaging policy for this message.\"),\n        null=True,  # Message can be built from scratch without using templates\n        blank=True,\n        on_delete=models.SET_NULL,\n    )\n    channel = models.CharField(\n        verbose_name=_(\"Channel\"),\n        help_text=_(\"ID of channel this message sent to.\"),\n        blank=False,\n        max_length=128,  # Maximum length of channel name is 80 characters\n    )\n    header = models.JSONField(\n        verbose_name=_(\"Header\"),\n        help_text=_(\n            \"Slack control arguments.\"\n            \" Allowed fields are `mrkdwn`, `parse`, `reply_broadcast`, `thread_ts`, `unfurl_links`, `unfurl_media`.\",\n        ),\n        validators=[header_validator],\n    )\n    body = models.JSONField(\n        verbose_name=_(\"Body\"),\n        help_text=_(\n            \"Message body.\"\n            \" Allowed fields are `attachments`, `body`, `text`, `icon_emoji`, `icon_url`, `metadata`, `username`.\",\n        ),\n        validators=[body_validator],\n    )\n    ok = models.BooleanField(\n        verbose_name=_(\"OK\"),\n        help_text=_(\"Whether Slack API respond with OK. If never sent, will be `null`.\"),\n        null=True,\n        default=None,\n    )\n    permalink = models.CharField(\n        verbose_name=_(\"Permalink\"),\n        help_text=_(\"Permanent link for this message.\"),\n        max_length=256,\n        default=\"\",\n        blank=True,\n    )\n\n    # As ID, `ts` assigned by Slack, it is known after received response\n    # By known, `ts` refers to timestamp (Format of `datetime.timestamp()`, e.g. `\"1702737142.945359\"`)\n    ts = models.CharField(\n        verbose_name=_(\"Message ID\"),\n        help_text=_(\"ID of an Slack message.\"),\n        max_length=32,\n        null=True,\n        blank=True,\n        unique=True,\n    )\n    parent_ts = models.CharField(\n        verbose_name=_(\"Thread ID\"),\n        help_text=_(\"ID of current conversation thread.\"),\n        max_length=32,\n        default=\"\",\n        blank=True,\n    )\n\n    # Extraneous call detail for debugging\n    request = models.JSONField(\n        verbose_name=_(\"Request\"),\n        help_text=_(\"Dump of request content for debugging.\"),\n        null=True,\n        blank=True,\n    )\n    response = models.JSONField(\n        verbose_name=_(\"Response\"),\n        help_text=_(\"Dump of response content for debugging.\"),\n        null=True,\n        blank=True,\n    )\n    exception = models.TextField(\n        verbose_name=_(\"Exception\"),\n        help_text=_(\"Exception message if any.\"),\n        blank=True,\n    )\n\n    objects: SlackMessageManager = SlackMessageManager()\n\n    class Meta:  # noqa: D106\n        verbose_name = _(\"Message\")\n        verbose_name_plural = _(\"Messages\")\n        ordering = (\"-created\",)\n\n    def __str__(self) -&gt; str:\n        if self.ok is True:\n            return _(\"Message ({ts}, OK)\").format(id=self.id, ts=self.ts)\n\n        if self.ok is False:\n            return _(\"Message ({id}, not OK)\").format(id=self.id)\n\n        return _(\"Message ({id}, not sent)\").format(id=self.id)\n</code></pre>"},{"location":"api-references/slack-messages/models/#django_slack_tools.slack_messages.models.SlackMessageRecipient","title":"<code>django_slack_tools.slack_messages.models.SlackMessageRecipient</code>","text":"<p>               Bases: <code>TimestampMixin</code>, <code>Model</code></p> <p>People or group in channels receive messages.</p> Source code in <code>django_slack_tools/slack_messages/models/message_recipient.py</code> <pre><code>class SlackMessageRecipient(TimestampMixin, models.Model):\n    \"\"\"People or group in channels receive messages.\"\"\"\n\n    alias = models.CharField(\n        verbose_name=_(\"Alias\"),\n        help_text=_(\"Alias for this recipient.\"),\n        max_length=256,\n        unique=True,\n    )\n    channel = models.CharField(\n        verbose_name=_(\"Channel\"),\n        help_text=_(\"Slack channel ID where messages will be sent.\"),\n        max_length=128,\n        blank=False,\n    )\n    channel_name = models.CharField(\n        verbose_name=_(\"Channel name\"),\n        help_text=_(\"Display name of channel.\"),\n        max_length=256,\n        blank=True,\n        default=\"\",\n    )\n    mentions = models.ManyToManyField(\n        SlackMention,\n        verbose_name=_(\"Mentions\"),\n        help_text=_(\"List of mentions.\"),\n        blank=True,\n    )\n\n    objects: SlackMessageRecipientManager = SlackMessageRecipientManager()\n\n    class Meta:  # noqa: D106\n        verbose_name = _(\"Recipient\")\n        verbose_name_plural = _(\"Recipients\")\n\n    def __str__(self) -&gt; str:\n        num_mentions = self.mentions.count()\n\n        return _(\"{alias} ({channel}, {num_mentions} mentions)\").format(\n            alias=self.alias,\n            channel=self.channel,\n            num_mentions=num_mentions,\n        )\n</code></pre>"},{"location":"api-references/slack-messages/models/#django_slack_tools.slack_messages.models.SlackMessagingPolicy","title":"<code>django_slack_tools.slack_messages.models.SlackMessagingPolicy</code>","text":"<p>               Bases: <code>TimestampMixin</code>, <code>Model</code></p> <p>An Slack messaging policy which determines message content and those who receive messages.</p> Source code in <code>django_slack_tools/slack_messages/models/messaging_policy.py</code> <pre><code>class SlackMessagingPolicy(TimestampMixin, models.Model):\n    \"\"\"An Slack messaging policy which determines message content and those who receive messages.\"\"\"\n\n    code = models.CharField(\n        verbose_name=_(\"Code\"),\n        help_text=_(\"Unique message code for lookup, mostly by human.\"),\n        max_length=32,\n        unique=True,\n    )\n    enabled = models.BooleanField(\n        verbose_name=_(\"Enabled\"),\n        help_text=_(\"Turn on or off current messaging policy.\"),\n        default=True,\n    )\n    recipients = models.ManyToManyField(\n        SlackMessageRecipient,\n        verbose_name=_(\"Message recipients\"),\n        help_text=_(\"Those who will receive messages.\"),\n    )\n    header_defaults = models.JSONField(\n        verbose_name=_(\"Default header\"),\n        help_text=_(\"Default header values applied to messages on creation.\"),\n        validators=[header_validator],\n        blank=True,\n        default=dict,\n    )\n    template = models.JSONField(\n        verbose_name=_(\"Message template object\"),\n        help_text=_(\"Dictionary-based template object.\"),\n        validators=[dict_template_validator],\n        null=True,\n        blank=True,\n    )\n    # Type is too obvious but due to limits...\n    objects: SlackMessagingPolicyManager = SlackMessagingPolicyManager()\n\n    class Meta:  # noqa: D106\n        verbose_name = _(\"Messaging Policy\")\n        verbose_name_plural = _(\"Messaging Policies\")\n\n    def __str__(self) -&gt; str:\n        num_recipients = self.recipients.all().count()\n        if self.enabled:\n            return _(\"{code} (enabled, {num_recipients} recipients)\").format(\n                code=self.code,\n                num_recipients=num_recipients,\n            )\n\n        return _(\"{code} (disabled, {num_recipients} recipients)\").format(code=self.code, num_recipients=num_recipients)\n</code></pre>"},{"location":"api-references/slack-messages/sending-messages/","title":"Sending Messages","text":""},{"location":"api-references/slack-messages/sending-messages/#django_slack_tools.slack_messages.message.slack_message","title":"<code>django_slack_tools.slack_messages.message.slack_message(body, *, channel, header=None, raise_exception=False, get_permalink=False)</code>","text":"<p>Send a simple text message.</p> <p>Parameters:</p> Name Type Description Default <code>body</code> <code>str | MessageBody | dict[str, Any]</code> <p>Message content, simple message or full request body.</p> required <code>channel</code> <code>str</code> <p>Channel to send message.</p> required <code>header</code> <code>MessageHeader | dict[str, Any] | None</code> <p>Slack message control header.</p> <code>None</code> <code>raise_exception</code> <code>bool</code> <p>Whether to re-raise caught exception while sending messages.</p> <code>False</code> <code>get_permalink</code> <code>bool</code> <p>Try to get the message permalink via extraneous Slack API calls.</p> <code>False</code> <p>Returns:</p> Type Description <code>SlackMessage | None</code> <p>Sent message instance or <code>None</code>.</p> Source code in <code>django_slack_tools/slack_messages/message.py</code> <pre><code>def slack_message(\n    body: str | MessageBody | dict[str, Any],\n    *,\n    channel: str,\n    header: MessageHeader | dict[str, Any] | None = None,\n    raise_exception: bool = False,\n    get_permalink: bool = False,\n) -&gt; SlackMessage | None:\n    \"\"\"Send a simple text message.\n\n    Args:\n        body: Message content, simple message or full request body.\n        channel: Channel to send message.\n        header: Slack message control header.\n        raise_exception: Whether to re-raise caught exception while sending messages.\n        get_permalink: Try to get the message permalink via extraneous Slack API calls.\n\n    Returns:\n        Sent message instance or `None`.\n    \"\"\"\n    # If body is just an string, make a simple message body\n    body = MessageBody(text=body) if isinstance(body, str) else MessageBody.model_validate(body)\n    header = MessageHeader.model_validate(header or {})\n\n    return app_settings.backend.send_message(\n        channel=channel,\n        header=header,\n        body=body,\n        raise_exception=raise_exception,\n        get_permalink=get_permalink,\n    )\n</code></pre>"},{"location":"api-references/slack-messages/sending-messages/#django_slack_tools.slack_messages.message.slack_message_via_policy","title":"<code>django_slack_tools.slack_messages.message.slack_message_via_policy(policy, *, header=None, raise_exception=False, lazy=False, get_permalink=False, context=None)</code>","text":"<p>Send a simple text message.</p> <p>Mentions for each recipient will be passed to template as keyword <code>{mentions}</code>. Template should include it to use mentions.</p> <p>Parameters:</p> Name Type Description Default <code>policy</code> <code>str | SlackMessagingPolicy</code> <p>Messaging policy code or policy instance.</p> required <code>header</code> <code>MessageHeader | dict[str, Any] | None</code> <p>Slack message control header.</p> <code>None</code> <code>raise_exception</code> <code>bool</code> <p>Whether to re-raise caught exception while sending messages.</p> <code>False</code> <code>lazy</code> <code>bool</code> <p>Decide whether try create policy with disabled, if not exists.</p> <code>False</code> <code>get_permalink</code> <code>bool</code> <p>Try to get the message permalink via extraneous Slack API calls.</p> <code>False</code> <code>context</code> <code>dict[str, Any] | None</code> <p>Dictionary to pass to template for rendering.</p> <code>None</code> <p>Returns:</p> Type Description <code>list[SlackMessage | None]</code> <p>Sent message instance or <code>None</code>.</p> <p>Raises:</p> Type Description <code>DoesNotExist</code> <p>Policy for given code does not exists.</p> Source code in <code>django_slack_tools/slack_messages/message.py</code> <pre><code>def slack_message_via_policy(  # noqa: PLR0913\n    policy: str | SlackMessagingPolicy,\n    *,\n    header: MessageHeader | dict[str, Any] | None = None,\n    raise_exception: bool = False,\n    lazy: bool = False,\n    get_permalink: bool = False,\n    context: dict[str, Any] | None = None,\n) -&gt; list[SlackMessage | None]:\n    \"\"\"Send a simple text message.\n\n    Mentions for each recipient will be passed to template as keyword `{mentions}`.\n    Template should include it to use mentions.\n\n    Args:\n        policy: Messaging policy code or policy instance.\n        header: Slack message control header.\n        raise_exception: Whether to re-raise caught exception while sending messages.\n        lazy: Decide whether try create policy with disabled, if not exists.\n        get_permalink: Try to get the message permalink via extraneous Slack API calls.\n        context: Dictionary to pass to template for rendering.\n\n    Returns:\n        Sent message instance or `None`.\n\n    Raises:\n        SlackMessagingPolicy.DoesNotExist: Policy for given code does not exists.\n    \"\"\"\n    if isinstance(policy, str):\n        if lazy:\n            policy, created = SlackMessagingPolicy.objects.get_or_create(code=policy, defaults={\"enabled\": False})\n            if created:\n                logger.warning(\"Policy for code %r created because `lazy` is set.\", policy)\n        else:\n            policy = SlackMessagingPolicy.objects.get(code=policy)\n\n    if not policy.enabled:\n        return []\n\n    header = MessageHeader.model_validate(header or {})\n    context = context or {}\n\n    # Prepare template\n    template = policy.template\n    overridden_reserved = {\"mentions\", \"mentions_as_str\"} &amp; set(context.keys())\n    if overridden_reserved:\n        logger.warning(\n            \"Template keyword argument(s) %s reserved for passing mentions, but already exists.\"\n            \" User provided value will override it.\",\n            \", \".join(f\"`{s}`\" for s in overridden_reserved),\n        )\n\n    messages: list[SlackMessage | None] = []\n    for recipient in policy.recipients.all():\n        # Auto-generated reserved kwargs\n        mentions: list[SlackMention] = list(recipient.mentions.all())\n        mentions_as_str = \", \".join(mention.mention for mention in mentions)\n\n        # Prepare rendering arguments\n        kwargs = {\"mentions\": mentions, \"mentions_as_str\": mentions_as_str}\n        kwargs.update(context)\n\n        # Render and send message\n        rendered = render(template, **kwargs)\n        body = MessageBody.model_validate(rendered)\n        message = app_settings.backend.send_message(\n            policy=policy,\n            channel=recipient.channel,\n            header=header,\n            body=body,\n            raise_exception=raise_exception,\n            get_permalink=get_permalink,\n        )\n        messages.append(message)\n\n    return messages\n</code></pre>"},{"location":"tutorials/quick-start/","title":"Quick Start","text":""},{"location":"tutorials/quick-start/#installation","title":"Installation","text":"<p>django-slack-tools supports Python 3.8+ and Django 3.2+. Supports for each deps will be dropped as soon as the ends of security updates.</p> <p>Install the package:</p> <pre><code>$ pip install django-slack-tools\n</code></pre> <p>Add the app to the your Django settings:</p> <pre><code>INSTALLED_APPS = [\n    ...\n    \"django.contrib.messages\", # Used in admin\n    \"django_slack_tools.slack_messages\",\n    ...\n]\n</code></pre> <p>Add configuration for application:</p> <pre><code>DJANGO_SLACK_TOOLS = {\n    # Module path to Slack Bolt application or callable returns the app\n    \"SLACK_APP\": \"path.to.your.slack.app\",\n\n    # Messaging backend configuration\n    \"BACKEND\": {\n        \"NAME\": \"django_slack_tools.slack_messages.backends.SlackBackend\",\n        \"OPTIONS\": {\n            \"slack_app\": \"path.to.your.slack.app\",\n        }\n    }\n}\n</code></pre> <p>Then, run the database migration (<code>python manage.py migrate</code>) and send messages:</p> <pre><code>from django_slack_tools.slack_messages.message import slack_message\n\nmessage = slack_message(\n    \"I like threading\",\n    channel=\"id-of-channel\",\n    header={\"reply_broadcast\": True},\n)\n</code></pre> <p>Check examples for about more usages.</p>"}]}